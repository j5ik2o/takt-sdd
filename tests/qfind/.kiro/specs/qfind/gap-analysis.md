## サマリー
- 対象 feature は `qfind` で確定し、要件は `.kiro/specs/qfind/requirements.md` に存在する（ABORT条件は非該当）。
- 既存コードベースには Rust プロダクト資産（`Cargo.toml`、`src/main.rs`、`tests/`）が存在せず、要件1〜7を満たす実装は未着手。
- `.kiro/steering/` は空で追加ガードレールはないため、現時点の制約は要件本文と本ムーブメントのポリシーが中心。
- 技術的な主要課題は「`.gitignore` 尊重」「Rayonでの並列走査」「並列でも決定的な出力順の保証」の両立。
- 推奨は C（ハイブリッド）: `cargo init` を土台に、CLI/探索/マッチング/出力を分離して実装し、統合テストで契約を固定する。

## 要件-資産マッピング

### 現状調査（既存資産）
- ドメイン関連ファイル: なし（`src/` は空、Rust実装なし）。
- 再利用可能コンポーネント: なし（検索ロジック、CLIパーサ、出力整形、テスト基盤すべて未実装）。
- 既存アーキテクチャパターン: 実質未定義（新規設計が必要）。
- 統合サーフェス候補: CLI引数、ファイルシステム走査、`.gitignore` 判定、正規表現評価、標準出力（text/JSON）、終了コード。

### 技術的ニーズ
- CLI引数解析（glob, regex, jsonフラグ, max-depth, root path）。
- globパターンコンパイルとエラー化。
- regexコンパイルとエラー化。
- `.gitignore` ルールに基づく除外判定。
- Rayonを用いた並列ディレクトリ走査。
- 並列実行でも同一結果を返すための正規化（例: パスソート）。
- JSON/textの2系統出力と終了コード規約。
- ユニットテスト + 統合テスト（CLI実行）基盤。

| 要件 | 既存資産 | ギャップタグ | ギャップ内容 |
|---|---|---|---|
| 1. globマッチング | なし | Missing | glob入力、コンパイル、マッチング、エラー終了の全実装が必要 |
| 2. regex内容検索 | なし | Missing | regex入力、コンパイル、内容走査、エラー終了の全実装が必要 |
| 3. `.gitignore` 尊重 | なし | Missing | `.gitignore` 読み込み/判定ロジックと探索連携が必要 |
| 4. 並列走査（Rayon） | なし | Missing | Rayon前提の探索実装・権限エラー継続・決定的結果化が必要 |
| 5. JSON出力 | なし | Missing | 出力モデル定義、JSONシリアライズ、textとの切替が必要 |
| 6. 最大深度制限 | なし | Missing | 深度計測・境界条件（0含む）・入力検証が必要 |
| 7. `cargo init` + テスト | なし | Missing | プロジェクト初期化、ユニット/統合テスト、`cargo test` 成功状態の構築が必要 |
| 8. 要件依存管理 | 要件文書のみ | Constraint | 実装順序を 1/2/3/6 → 4 → 5 → 7 で固定しないと受入条件が崩れる |

### 制約・未知事項
- `Constraint`: 命名・構造ルール上、責務不明な `*Manager` / `*Util` 命名や肥大ファイル（200行超）を避ける必要がある。
- `Constraint`: `.gitignore` の扱いは「存在時のみ適用」が必須で、非存在時に暗黙除外をしてはいけない。
- `Unknown`: バイナリファイルやUTF-8不正ファイルの内容検索ポリシー（スキップ/エラー/lossy）が要件に未明記。
- `Unknown`: 権限エラー時の通知方法（stderr警告の有無）は要件に未明記（継続探索のみ明記）。

## 実装アプローチ

### A: 既存拡張（`src/main.rs` 中心の単一実装）
- メリット: 初期ファイル数が最小、最短で動作到達しやすい。
- デメリット: 走査・判定・出力・CLI責務が集中し、要件4/5/7で急速に肥大化しやすい。
- 評価: 現在資産がないため「既存拡張」の利点が小さく、中長期の保守性で不利。

### B: 新規作成（機能単位で完全分離）
- メリット: 責務分離が明確で、ユニットテストしやすい。
- デメリット: 初期設計・ファイル作成コストが増える。
- 評価: 品質は高いが、初手から分割しすぎると過剰設計になるリスク。

### C: ハイブリッド（推奨）
- 構成方針: `cargo init` で開始し、最小分割で `cli` / `search` / `output` / `error` / `main` を分離。
- メリット: Bより軽量、Aより責務分離が明確。要件追加時の拡張余地を確保できる。
- デメリット: Aより初期の設計判断が増える（特に結果モデルとエラー契約）。
- 評価: 現在の空プロジェクトと要件ボリュームに対して、実装速度と保守性のバランスが最も良い。

## 工数・リスク
- 工数: **M (3-7日)**。根拠: 0からのCLI実装に加え、並列走査・`.gitignore`・JSON・統合テストまで一式必要。
- リスク: **Medium**。根拠: 技術自体は既知（Rust + Rayon + regex）だが、並列性と決定的出力の両立に設計注意が必要。

## 設計フェーズへの推奨事項
- 推奨アプローチ: **C（ハイブリッド）** を採用し、要件依存順（1/2/3/6→4→5→7）で設計する。
- 要調査項目1: Rayonで「並列走査」を満たしつつ `.gitignore` 判定をどの層で適用するか（走査前フィルタ/走査中判定）。
- 要調査項目2: 並列結果の安定化方式（最終ソートキー、パス正規化規則）。
- 要調査項目3: 内容検索時の非UTF-8ファイルの扱いを明文化し、ユニットテストに落とす。
- 要調査項目4: エラー分類（入力不正は非0終了、探索中の権限エラーは継続）をCLI契約として固定する。
- 要調査項目5: 統合テストの実行方式（`assert_cmd` + 一時ディレクトリ生成）と JSON/text 出力検証方法を確定する。
